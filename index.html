<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vic's Posts</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/avatar.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/vicerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/wang-jin-liang-69" target="_blank" class="nav-list-link">ZHIHU</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/29/gulpIncrementalBuild/" class="post-title-link">Gulp中的增量编译</a></h2><div class="post-meta"><div class="post-time">Jan 29, 2016</div></div><div class="post-content"><p><a href="http://gulpjs.com">Gulp.js</a>是目前前端非常流行的自动化构建工具，它基于流，代码优于配置，API简单，又有着大量优秀的第三方插件。它的<code>gulp.watch()</code>接口，可以让我们监听文件改动而进行自动构建，但是如果存在耗时的任务或者随着项目的逐渐增大，可能每次构建都要花费很多的时间，那么在Gulp中有什么解决的办法呢？<br></div><a href="2016/01/29/gulpIncrementalBuild/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/15/extendInBabel/" class="post-title-link">从babel编译es6类继承的一个坑说起</a></h2><div class="post-meta"><div class="post-time">Jan 15, 2016</div></div><div class="post-content"><p>在es6发布之前，我相信所有学习javascript中面向对象编程的同学，都会觉得在javascript中实现类啊，实现继承啊特别麻烦，君不见实现继承，就有原型模式，借助构造函数模式，混合模式，寄生模式，寄生混合模式等等，但是好在es6中对这门语言进行了很多扩展，其中就包括类(Class)的概念以及继承实现方式的提出。虽然本质上类仍然是对javascript中传统构造函数的一层包装，但是书写方式变得非常简单而且也不用再考虑什么最佳实践了。但是要想把他们应用在浏览器端，那自然少不了es6伴侣 ── <a href="https://babeljs.io/">babel</a>了，那在使用过程中有没有什么坑啊，笔者这里就介绍一个关于前面讲的继承的坑以及顺带讲讲babel中如是何实现继承的。</p></div><a href="2016/01/15/extendInBabel/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/24/es6InSublime/" class="post-title-link">在sublime中编译ES6语法</a></h2><div class="post-meta"><div class="post-time">Dec 24, 2015</div></div><div class="post-content"><p>ECMAScript 6是JavaScript语言的下一代标准，已经在2015年6月正式发布了。那么我们如何学习测试ES6新提出的那些特性呢，是写一个带有javascript的html文件在浏览器里运行下或者在浏览器的控制台输入js代码么？显然不靠谱啊，浏览器对新标准的支持总是滞后的。我知道，你想说还有node，babel呢，但是通过终端的REPL或者执行babel的编译命令查看运行结果，还是很麻烦嘛，还好，我们还可以通过sublime打造我们的js编译运行环境。</p></div><a href="2015/12/24/es6InSublime/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/29/textareaAutosize/" class="post-title-link">让textarea高度随输入自适应</a></h2><div class="post-meta"><div class="post-time">Nov 29, 2015</div></div><div class="post-content"><p>让一个可编辑的div实现高度随输入自适应，很简单，只要设置下它的<code>min-height</code>就好了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">contenteditable</span>=<span class="value">"true"</span> <span class="attribute">style</span>=<span class="value">"width:200px;min-height:100px;border:1px solid #e8e8e8"</span> &gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显然这招放在textarea上并不怎么管用，那么如何让一个textarea也做到像div一样的伸缩自如呢？</p></div><a href="2015/11/29/textareaAutosize/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/28/textChange/" class="post-title-link">跨浏览器监听用户输入</a></h2><div class="post-meta"><div class="post-time">Nov 28, 2015</div></div><div class="post-content"><p>在前端的开发中，我们经常面临着这样的需求，需要统计在<code>input[type=text]</code>或者<code>textarea</code>中用户输入的字数，以便给用户一些输入限制的提示，那么我们如何实现跨浏览器的监听用户在文本框的输入呢？</p></div><a href="2015/11/28/textChange/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/18/inputfile/nativePreview/" class="post-title-link">关于input[type=file]那些事：如何本地预览图片</a></h2><div class="post-meta"><div class="post-time">Nov 18, 2015</div></div><div class="post-content"><p>在浏览器中怎样能看到自己刚通过<code>input[type=file]</code>选中的图片文件呢，一般的做法，是将图片文件异步上传到服务器，获取它在服务器的url，再将这个url赋值给一个img元素的src属性来实现的，这种做法往往会在服务器端产生大量的临时资源，而且还浪费了流量。那么如何不借助服务器，在本地实现图片的预览功能呢？对于现代浏览器，我们可以使用HTML5的File API，而对于不支持它们的IE9及其以下版本我们可以借助IE的滤镜来实现。</p></div><a href="2015/11/18/inputfile/nativePreview/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/17/inputfile/uploadFile/" class="post-title-link">关于input[type=file]那些事：如何异步上传文件</a></h2><div class="post-meta"><div class="post-time">Nov 17, 2015</div></div><div class="post-content"><p>我们都知道可以通过ajax请求来异步向服务器提交表单，那是不是其中也包括<code>input[type=file]</code>这个特殊的表单元素呢？如果不可以，那除了flash外，还有没有其他的方法可以实现异步提交文件呢？</p></div><a href="2015/11/17/inputfile/uploadFile/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/16/inputfile/clearValue/" class="post-title-link">关于input[type=file]那些事：如何清空值</a></h2><div class="post-meta"><div class="post-time">Nov 16, 2015</div></div><div class="post-content"><p>这又是一个容易想当然的问题，将<code>input[type=file]</code>的value设置为空就行了么？在chrome和firefox确实是没有问题的，但是在IE8/9/10中，然并卵（IE11没有这个问题）。</p></div><a href="2015/11/16/inputfile/clearValue/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/15/inputfile/customCSS/" class="post-title-link">关于input[type=file]那些事：如何定制样式</a></h2><div class="post-meta"><div class="post-time">Nov 15, 2015</div></div><div class="post-content"><p><code>&lt;input type=&quot;file&quot;&gt;</code>由一个文本区域和一个浏览按钮组成，用于文件上传，是HTML表单元素中比较特殊的一个。由于涉及到向服务器上传文件这样敏感的安全问题，所以浏览器对其进行了诸多的限制，而且各家浏览器对其的支持也不尽相同，这给前端程序员的开发带来了很多麻烦。鉴于此，我准备写几篇关于<code>input[type=file]</code>的日常开发总结，希望能给大家带来帮助。</p></div><a href="2015/11/15/inputfile/customCSS/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/14/liftoff/" class="post-title-link">［译］Building Command Line Tools in Node with Liftoff</a></h2><div class="post-meta"><div class="post-time">Nov 14, 2015</div></div><div class="post-content"><p>作者：<a href="https://bocoup.com/about/bocouper/tyler-kellen">Tyler Kellen</a></p>
<p>原文：<a href="https://bocoup.com/weblog/building-command-line-tools-in-node-with-liftoff">https://bocoup.com/weblog/building-command-line-tools-in-node-with-liftoff</a></p>
<p>前一阵子在研究前端构建工具时，在<a href="http://www.gulpjs.com.cn/">gulp</a>和<a href="http://fis.baidu.com/">fis3</a>中都发现了<a href="https://www.npmjs.com/package/liftoff">liftoff</a>的身影，国内关于这个模块的介绍资料很少，于是就起了翻译下模块作者这篇博文的念头。</p></div><a href="2015/11/14/liftoff/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>