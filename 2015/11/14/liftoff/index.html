<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ［译］Building Command Line Tools in Node with Liftoff · Vic's Posts</title><meta name="description" content="［译］Building Command Line Tools in Node with Liftoff - vic"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/avatar.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/vicerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/wang-jin-liang-69" target="_blank" class="nav-list-link">ZHIHU</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">［译］Building Command Line Tools in Node with Liftoff</h1><div class="post-meta"><div class="post-time">2015年11月14日</div></div><div class="post-content"><p>作者：<a href="https://bocoup.com/about/bocouper/tyler-kellen" target="_blank" rel="external">Tyler Kellen</a></p>
<p>原文：<a href="https://bocoup.com/weblog/building-command-line-tools-in-node-with-liftoff" target="_blank" rel="external">https://bocoup.com/weblog/building-command-line-tools-in-node-with-liftoff</a></p>
<p>前一阵子在研究前端构建工具时，在<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp</a>和<a href="http://fis.baidu.com/" target="_blank" rel="external">fis3</a>中都发现了<a href="https://www.npmjs.com/package/liftoff" target="_blank" rel="external">liftoff</a>的身影，国内关于这个模块的介绍资料很少，于是就起了翻译下模块作者这篇博文的念头。</p>
<a id="more"></a>
<h2 id="u8BD1_u6587"><a href="#u8BD1_u6587" class="headerlink" title="译文"></a>译文</h2><p>在node中编程，我最喜欢的一点就是包管理系统，在几乎所有的情况下，在每个项目安装本地模块的做法大大地简化了我作为一个开发者的工作。</p>
<p>然而，在长期作为Grunt项目一个贡献者的同时，我对某些特殊的使用情况越来越了解，这打破了我之前的想法。我创建了一个叫<a href="https://github.com/js-cli/js-liftoff" target="_blank" rel="external">Liftoff</a>的库去解决这个问题，希望能减少每个人关于这方面的烦恼。</p>
<p>如果你曾经开发过node的命令行工具，特别是某些需要插件的生态系统，那你就可能知道我讲的是什么。让我们看看<a href="https://github.com/js-cli/js-liftoff" target="_blank" rel="external">Liftoff</a>到底是解决什么问题的。</p>
<h3 id="u5168_u5C40_u6A21_u5757_u542B_u4E49"><a href="#u5168_u5C40_u6A21_u5757_u542B_u4E49" class="headerlink" title="全局模块含义"></a>全局模块含义</h3><p>在我深入介绍之前，先让我来解释一些事情来确保我们的思路是一致的。</p>
<ol>
<li>如果你想要一个模块提供一个在shell中使用的命令，最简单的方法就是全局安装它（<code>npm install -g modulename</code>），来让它在系统层面变得可用。</li>
<li>在不借助像<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>这样工具的情况下你不能全局安装一个模块的多个版本。</li>
<li>全局安装的模块不能够引入（<code>require</code>）其他全局安装的模块。</li>
<li>本地安装的模块不能够引入（<code>require</code>）全局安装的模块。</li>
</ol>
<p><strong>注意</strong>：所有的模块都能够访问全局安装的node的核心模块，像<code>fs</code>，<code>path</code>，<code>http</code>等。</p>
<h3 id="u8FD9_u610F_u5473_u7740_u4EC0_u4E48_uFF1F"><a href="#u8FD9_u610F_u5473_u7740_u4EC0_u4E48_uFF1F" class="headerlink" title="这意味着什么？"></a>这意味着什么？</h3><p>上面所介绍的全局模块的含义其实隐含了一些看起来不是很直观的问题：</p>
<ol>
<li>Node的命令行工具经常情况下全局本地都要安装。</li>
<li>全局安装的版本应该提供一个命令去找到并且加载本地安装的版本。</li>
<li>如果这个工具需要插件，一个本地安装的版本将不能访问任何全局安装的模块。插件需要被当作依赖特殊地安装在每一个项目下。</li>
</ol>
<p>如果你还是一个node的新手，这些可能会让你很困扰。我的建议？继续学习就好了，花费足够的时间，你就可以使用多个版本的工具和插件来构建项目了。</p>
<h3 id="u8BA9_u5168_u5C40_u5B89_u88C5_u548C_u672C_u5730_u5B89_u88C5_u53D8_u5F97_u6B63_u786E"><a href="#u8BA9_u5168_u5C40_u5B89_u88C5_u548C_u672C_u5730_u5B89_u88C5_u53D8_u5F97_u6B63_u786E" class="headerlink" title="让全局安装和本地安装变得正确"></a>让全局安装和本地安装变得正确</h3><p>为了方便讨论，让我们来开发一个叫<a href="http://github.com/tkellen/node-hacker" target="_blank" rel="external">hacker</a>的命令行工具，并且使用<code>Hackerfile</code>让他变得可配置。当我们在shell中运行<code>hacker</code>命令时，我们想让它在我们全局安装的版本中执行一个二进制文件（通过在我们工具的<code>package.json</code>文件的<a href="https://docs.npmjs.com/json#bin" target="_blank" rel="external">bin</a>属性指定）。就像刚才提到的，这个命令应该能发现并且加载一个我们<strong>本地</strong>安装的包，无论它是什么版本 。</p>
<p>因为全局安装的模块不能直接引入（<code>require</code>）本地安装的模块，要想让它运行起来，我们还得想点办法。值得庆幸的是，我们需要的解决方案在npm上已经有了。它叫<a href="https://github.com/substack/node-resolve" target="_blank" rel="external">resolve</a>，它通过一些方便的配置，包括指定一个基础的路径来开始搜素，再次实现了<a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="external">node是怎样寻找模块的</a>。</p>
<p>下面是到目前为止我们<code>hacker</code>这个可执行二进制文件的一个简单例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">var resolve = require('resolve');</span><br><span class="line">try &#123;</span><br><span class="line">  var localHacker = resolve.sync('hacker', &#123; basedir: process.cwd() &#125;);</span><br><span class="line">  console.log('Found hacker at', localHacker);</span><br><span class="line">  // kick off here</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log('Unable to find a local installation of hacker.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u8BA9_u5B83_u8FD0_u884C_u5F97_u66F4_u597D"><a href="#u8BA9_u5B83_u8FD0_u884C_u5F97_u66F4_u597D" class="headerlink" title="让它运行得更好"></a>让它运行得更好</h3><p>现在我们能够找到并且运行我们tool的一个本地的版本了！我们已经做得很完美了，对么？不完全是，有许多细节有待完善，现在让我们来看看它们吧。</p>
<h4 id="u667A_u80FD_u5730_u904D_u5386_u67E5_u627E"><a href="#u667A_u80FD_u5730_u904D_u5386_u67E5_u627E" class="headerlink" title="智能地遍历查找"></a>智能地遍历查找</h4><p>当我们运行<code>hacker</code>命令时，我们可能是在我们项目的一个子目录中。如果我们的工具足够聪明以至于能够去遍历文件系统找到一个在最近的上级目录中的<code>Hackerfile</code>，那就太好了。又一次的，npm上已经有了一个解决这个问题的模块—它叫做<a href="https://github.com/cowboy/node-findup-sync" target="_blank" rel="external">findup-sync</a>，下面是我们如何来使用它：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">var resolve = require('resolve');</span><br><span class="line">var findup = require('findup-sync');</span><br><span class="line">var path = require('path');</span><br><span class="line">var cwd = process.cwd();</span><br><span class="line"></span><br><span class="line">var configFile = findup('Hackerfile.js', &#123; cwd: cwd &#125;);</span><br><span class="line">if (configFile) &#123;</span><br><span class="line">  console.log('Found Hackerfile:', configFile);</span><br><span class="line">  cwd = path.dirname(configFile);</span><br><span class="line">  process.chdir(cwd);</span><br><span class="line">  console.log('Setting current working directory:', cwd);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log('No Hackerfile found.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var localModule = resolve.sync('hacker', &#123; basedir: cwd &#125;);</span><br><span class="line">  if (localModule) &#123;</span><br><span class="line">    console.log('Found hacker module:', localModule);</span><br><span class="line">  &#125;</span><br><span class="line">  // kick off here</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log('Unable to find a local installation of hacker.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一旦找到了<code>Hackerfile</code>，我们会把当前进程的工作目录切换到它所在的目录中。通过这种方式，我们工具中执行任何的文件操作都是相对于我们的<code>Hackerfile</code>的。</p>
<h4 id="u660E_u786E_u5730_u6307_u5B9A_u76EE_u5F55"><a href="#u660E_u786E_u5730_u6307_u5B9A_u76EE_u5F55" class="headerlink" title="明确地指定目录"></a>明确地指定目录</h4><p>最终，我们可能需要在一个完全是我们项目目录之外的文件夹运行hacker命令。为了支持这个，我们需要开始去读取命令行的参数。我们立刻能想到许许多多的很棒的命令行参数的解析器<a href="https://github.com/substack/node-optimist" target="_blank" rel="external"> optimist</a>，<a href="https://github.com/substack/minimist" target="_blank" rel="external">minimist</a>，<a href="https://github.com/bcoe/yargs" target="_blank" rel="external"> yargs</a>，<a href="https://github.com/harthur/nomnom" target="_blank" rel="external">nomnom</a>，<a href="https://github.com/npm/nopt" target="_blank" rel="external">nopt</a>以及<a href="https://github.com/tj/commander.js" target="_blank" rel="external">commander.js</a>，我们没有必要去重新造一个！</p>
<p>下面是当我们支持一个<code>--cwd</code>参数时的可执行二进制文件的内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">var resolve = require('resolve');</span><br><span class="line">var findup = require('findup-sync');</span><br><span class="line">var path = require('path');</span><br><span class="line">var argv = require('minimist')(process.argv.slice(2));</span><br><span class="line"></span><br><span class="line">var cwd = argv.cwd ? argv.cwd : process.cwd();</span><br><span class="line"></span><br><span class="line">var configFile = findup('Hackerfile.js', &#123; cwd: cwd &#125;);</span><br><span class="line">if (configFile) &#123;</span><br><span class="line">  console.log('Found Hackerfile:', configFile);</span><br><span class="line">  cwd = path.dirname(configFile);</span><br><span class="line">  process.chdir(cwd);</span><br><span class="line">  console.log('Setting current working directory:', cwd);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log('No Hackerfile found.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var localModule = resolve.sync('hacker', &#123; basedir: cwd &#125;);</span><br><span class="line">  if (localModule) &#123;</span><br><span class="line">    console.log('Found hacker module:', localModule);</span><br><span class="line">  &#125;</span><br><span class="line">  // kick off here</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log('Unable to find a local installation of hacker.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u914D_u7F6E_u652F_u6301js_u5F02_u6784_u8BED_u8A00"><a href="#u914D_u7F6E_u652F_u6301js_u5F02_u6784_u8BED_u8A00" class="headerlink" title="配置支持js异构语言"></a>配置支持js异构语言</h4><p>如果我们的工具得到了广泛的应用，一些人总是想通过一些我们没用过或者不关心的js异构语言来写他们自己的<code>HackerFile</code>。将它与我们的工具很明确地绑定在一起是一个很糟糕的主意，所以我们需要去支持另一个参数。让我们叫它<code>--require</code>。这是很棒的一件事，我们发现能够通过这个参数来解析和了解怎样去使用<a href="https://github.com/substack/node-resolve" target="_blank" rel="external">resolve</a>—我们需要找到更多的本地模块！</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">var resolve = require('resolve');</span><br><span class="line">var findup = require('findup-sync');</span><br><span class="line">var path = require('path');</span><br><span class="line">var argv = require('minimist')(process.argv.slice(2));</span><br><span class="line"></span><br><span class="line">var cwd = argv.cwd ? argv.cwd : process.cwd();</span><br><span class="line">var requires = argv.require;</span><br><span class="line"></span><br><span class="line">if (requires) &#123;</span><br><span class="line">  if (!Array.isArray(requires)) &#123;</span><br><span class="line">    requires = [requires];</span><br><span class="line">  &#125;</span><br><span class="line">  requires.forEach(function (module) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      require(resolve.sync(module, &#123; basedir: cwd &#125;));</span><br><span class="line">      console.log('Loading external module:', module);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log('Unable to load:', module, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var validExtensions = Object.keys(require.extensions).join(',');</span><br><span class="line">var configNameRegex = 'Hackerfile'+'&#123;'+validExtensions+'&#125;';</span><br><span class="line"></span><br><span class="line">var configFile = findup(configNameRegex, &#123; cwd: cwd &#125;);</span><br><span class="line">if (configFile) &#123;</span><br><span class="line">  console.log('Found Hackerfile:', configFile);</span><br><span class="line">  cwd = path.dirname(configFile);</span><br><span class="line">  process.chdir(cwd);</span><br><span class="line">  console.log('Setting current working directory:', cwd);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log('No Hackerfile found.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var localModule = resolve.sync('hacker', &#123; basedir: cwd &#125;);</span><br><span class="line">  if (localModule) &#123;</span><br><span class="line">    console.log('Found hacker module:', localModule);</span><br><span class="line">  &#125;</span><br><span class="line">  // kick off here</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log('Unable to find a local installation of hacker.');</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，代替去查找一个以<code>.js</code>作为后缀名的<code>Hackerfile</code>的是，我们会去查找任何一个能够被node知道如何去加载解析的文件类型。如果我们像这样调用我们的命令：<code>hacker --require coffee-script/register</code>，我们的可执行二进制文件将会尝试从我们的本地依赖中加载coffee-script的解析器。如果加载成功，node就能够成功加载以<code>.coffee</code>作为后缀名的文件。</p>
<h4 id="u8BA9_u4E00_u5207_u53D8_u5F97_u66F4_u7B80_u5355"><a href="#u8BA9_u4E00_u5207_u53D8_u5F97_u66F4_u7B80_u5355" class="headerlink" title="让一切变得更简单"></a>让一切变得更简单</h4><p>在<a href="https://github.com/js-cli/js-liftoff" target="_blank" rel="external">Liftoff</a>中所有的这一切都是自动的，下面的这个例子做了我到目前为止所说的所有事情：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">var Liftoff = require('liftoff');</span><br><span class="line"></span><br><span class="line">var Hacker = new Liftoff(&#123;</span><br><span class="line">  name: 'hacker'</span><br><span class="line">&#125;).on('require', function (name, module) &#123;</span><br><span class="line">  console.log('Loading external module:', name);</span><br><span class="line">&#125;).on('requireFail', function (name, err) &#123;</span><br><span class="line">  console.log('Unable to load:', name, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Hacker.launch(function() &#123;</span><br><span class="line">  if(this.configPath) &#123;</span><br><span class="line">    process.chdir(this.configBase);</span><br><span class="line">    console.log('Setting current working directory:', this.configBase);</span><br><span class="line">    // kick off here</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log('No Hackerfile found.');</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下一个Grunt的主要版本（托管在<a href="https://github.com/gruntjs/grunt-next" target="_blank" rel="external">这里</a>）将会采用<a href="https://github.com/js-cli/js-liftoff" target="_blank" rel="external">Liftoff</a>。其他的库也开始使用它，<a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a>目前正在使用，<a href="https://github.com/mdevils/node-jscs" target="_blank" rel="external">jscs</a>也马上准备开始使用。我希望这个可重复使用的解决方案能够帮助其他的开发者去创建更好的工具！</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/11/15/inputfile/customCSS/" class="prev">上一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'fedviccom';
var disqus_identifier = '2015/11/14/liftoff/';
var disqus_title = '［译］Building Command Line Tools in Node with Liftoff';
var disqus_url = 'http://fedvic.com/2015/11/14/liftoff/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fedviccom.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://fedvic.com">vic</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>