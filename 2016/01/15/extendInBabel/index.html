<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从babel编译es6类继承的一个坑说起 · Vic's Posts</title><meta name="description" content="从babel编译es6类继承的一个坑说起 - vic"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/avatar.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/vicerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/wang-jin-liang-69" target="_blank" class="nav-list-link">ZHIHU</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">从babel编译es6类继承的一个坑说起</h1><div class="post-meta"><div class="post-time">Jan 15, 2016</div></div><div class="post-content"><p>在es6发布之前，我相信所有学习javascript中面向对象编程的同学，都会觉得在javascript中实现类啊，实现继承啊特别麻烦，君不见实现继承，就有原型模式，借助构造函数模式，混合模式，寄生模式，寄生混合模式等等，但是好在es6中对这门语言进行了很多扩展，其中就包括类(Class)的概念以及继承实现方式的提出。虽然本质上类仍然是对javascript中传统构造函数的一层包装，但是书写方式变得非常简单而且也不用再考虑什么最佳实践了。但是要想把他们应用在浏览器端，那自然少不了es6伴侣 ── <a href="https://babeljs.io/" target="_blank" rel="external">babel</a>了，那在使用过程中有没有什么坑啊，笔者这里就介绍一个关于前面讲的继承的坑以及顺带讲讲babel中如是何实现继承的。</p>
<a id="more"></a>
<h2 id="u600E_u4E48_u9047_u5230_u7684_u8FD9_u4E2A_u5751"><a href="#u600E_u4E48_u9047_u5230_u7684_u8FD9_u4E2A_u5751" class="headerlink" title="怎么遇到的这个坑"></a>怎么遇到的这个坑</h2><p>前几周在学习<a href="http://facebook.github.io/react/" target="_blank" rel="external">React</a>后，非常喜欢React面向组件自定义标签的开发方式，于是就决定尝试将公司的基础组件用React重写下，而React还支持<a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus/" target="_blank" rel="external">es6的写法</a>，那就来个React+ES6+Babel吧。比如像下面这样定义个Input组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.props.defaultValue</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="title">input</span> &#123;<span class="attribute">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="title">Input</span> /&gt;</span>,</span><br><span class="line">    document.getElementById('example')</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>在Chrome，IE11中一切很完美，但是IE10怎么就抛错了：<em>无法获取未定义或 null 引用的属性“defaultValue”</em>？那我们接下来就看看babel中是如何实现继承的。</p>
<h2 id="babel_u4E2D_u5982_u4F55_u5B9E_u73B0_u7684_u7EE7_u627F_uFF1F"><a href="#babel_u4E2D_u5982_u4F55_u5B9E_u73B0_u7684_u7EE7_u627F_uFF1F" class="headerlink" title="babel中如何实现的继承？"></a>babel中如何实现的继承？</h2><p>我们来举一个更简单的es6类继承的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent(<span class="string">'vic'</span>).name);</span><br></pre></td></tr></table></figure>
<p>下面是被babel编译之后格式化的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>) ? call : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function, not "</span> + <span class="keyword">typeof</span> superClass);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        constructor: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span>(<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> _this = _possibleConstructorReturn(<span class="keyword">this</span>, <span class="built_in">Object</span>.getPrototypeOf(Child).call(<span class="keyword">this</span>, name));</span><br><span class="line"></span><br><span class="line">        _this.age = age;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Child;</span><br><span class="line">&#125;)(Parent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent(<span class="string">'vic'</span>).name);</span><br></pre></td></tr></table></figure>
<h3 id="Object-create_28_29"><a href="#Object-create_28_29" class="headerlink" title="Object.create()"></a>Object.create()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: subClass,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>_inherits()</code>方法接收子类构造函数，父类构造函数两个参数，首先通过<code>Object.create()</code>方法以父类构造函数的原型为原型创建对象，并用它重写子类的原型来实现原型继承，为什么不用经典的原型继承方式<code>subClass.prototype = new superClass()</code>？<br></p>
<p>对javascript中面向对象编程有一定了解的人都知道，这种方式会多执行一遍父类的构造函数，并且会在子类的原型上多定义一组父类对象的实例属性，在es3中可以借助寄生式(parasitic)继承的方式解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = obj(Parent.prototype);</span><br></pre></td></tr></table></figure>
<p>原理就是借助一个空构造函数来实现干净的原型继承，而在es5中对以某个对象作为原型创建新对象的这种方法进行了规范，那就是<code>Object.create()</code>。<br></p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>我们发现babel在调用这个方法的时候，还传入了第二个参数，一个表示多个属性描述器(property descriptor)的对象，它又是用来做什么的呢？经典的原型继承方式，还有一个问题就是重写子类原型后，子类原型指向构造函数的指针(constructor)指向了父类的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child().construcotr); <span class="comment">// Parent</span></span><br></pre></td></tr></table></figure>
<p>解决的办法倒也很简单，重新指回去就行了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure>
<p>但是这又带来了一个新的问题，那就是<code>constructor</code>原本是不可枚举的属性（属性的enumerable为fasle），在<code>for in</code>或者<code>Object.keys()</code>中是无法遍历出来的，但是如果直接对<code>constructor</code>赋值的话，就会让它重新变成一个可枚举的属性，在ES5中可以通过传入属性描述的方式解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Child.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">     value: Child,</span><br><span class="line">     enumerable: <span class="literal">false</span>,</span><br><span class="line">     writable: <span class="literal">true</span>,</span><br><span class="line">     configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然了我们也可以像babel那样直接通过<code>Object.create()</code>一步完成原型继承，传入的第二个参数是类似于<code>Object.defineProperties()</code>方法中传入的对象参数，它们也会成为新建对象的原型属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: subClass,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="getPrototypeOf_28_29/setPrototypeOf_28_29"><a href="#getPrototypeOf_28_29/setPrototypeOf_28_29" class="headerlink" title="getPrototypeOf()/setPrototypeOf()"></a>getPrototypeOf()/setPrototypeOf()</h3><p>了解javascript面向对象的人都知道实现了原型继承其实只实现了继承的一部分，原型继承一般只是用来继承父类的方法，父类的属性则往往需要子类重新声明，一般都是通过借助构造函数或者称之为对象冒充的方式解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看看babel中对此的实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _inherits()方法中</span></span><br><span class="line"><span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child构造函数中</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Child).call(<span class="keyword">this</span>, name)</span><br></pre></td></tr></table></figure>
<p>看起来要比刚才讲的借助构造函数实现复杂点，首先让我们来看下两个核心的方法， <code>getPrototypeOf()</code>是es5提出的用于获取一个对象原型对象的方法，<code>setPrototypeOf()</code>则是es6提出的用于设置一个对象原型对象的方法，因此上面的代码就表示我们将父类和子类的构造函数当作对象来处理，先让父类的构造函数成为子类构造函数的原型，再取得子类构造函数的原型，那不就是父类的构造函数么，也就是说绕了一个圈，和<code>Parent.call(this, name);</code>一个道理啊，那babel为什么要这么实现呢，而且这个实现还带来了我所说的那个坑。<br></p>
<p>先来看看为什么要这么实现，在es6中规定了类静态方法的实现，而静态属性也作为es7的一个提案得到了babel的支持，具体如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    static prop = <span class="string">'value'</span>;</span><br><span class="line">    static method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且静态属性和静态方法，是可以被子类继承的，babel为了实现这个继承，才让父类的构造函数设置为子类构造函数的原型，换句话说就是实现了子类构造函数对父类构造函数的继承，从而让子类也能获得父类的静态属性和方法。<br><br>为什么说这又是坑之所在呢，如前面所说<code>getPrototypeOf()</code>是ES5提出的方法，浏览器大多都对其进行了很好的支持(IE9+/Chrome/Firefox)，但是<code>setPrototypeOf()</code>则是在ES6中才提出的方法，IE在IE11时才开始支持这个方法，那意味着在IE10，IE9中根本不存在这个方法，就会执行<code>subClass.__proto__ = superClass;</code>这段代码，同样的<code>__proto__</code>也是在IE11才开始支持，所以这段代码在IE10以下的版本并没有什么用。那<code>Object.getPrototypeOf(Child)</code>获得结果是什么呢，就是<code>Function.prototype</code>，我们知道函数也是实例，函数实例的构造函数就是<code>Function</code>，那自然函数实例的原型就是<code>Function.prototype</code>了，显然不能通过它来执行父类<code>Parent</code>的构造函数，那么通过它构建的子类对象，也就自然不会有父类的实例属性<code>name</code>。回到最开始的React例子，在React es6的写法中，通过<code>state = {};</code>来声明实例属性<code>state</code>，babel编译后的代码大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    _inherits(Input, React.Component);</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(Input).call(<span class="keyword">this</span>, props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.props.defaultValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在IE10-中，就如前面说的<code>Object.getPrototypeOf(Input)</code>并没有得到父类的构造函数<code>React.Component</code>，而只是得到了函数实例真正的原型，对其进行对象冒充，不能复制父类的实例属性<code>props</code>，从而在下面调用<code>this.props.defaultValue</code>时报错。</p>
<h2 id="u600E_u4E48_u89E3_u51B3"><a href="#u600E_u4E48_u89E3_u51B3" class="headerlink" title="怎么解决"></a>怎么解决</h2><p>添加一个polyfill解决</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">Object</span>.setPrototypeOf || &#123;&#125;.__proto__)) &#123;</span><br><span class="line">    <span class="keyword">var</span> nativeGetPrototypeOf = <span class="built_in">Object</span>.getPrototypeOf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object.__proto__) &#123;</span><br><span class="line">            <span class="keyword">return</span> object.__proto__;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nativeGetPrototypeOf.call(<span class="built_in">Object</span>, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在IE10-中不存在<code>Object.setPrototypeOf()</code>方法，但是babel会设置子类构造函数的<code>__proto__</code>为父类构造函数，那么就可以在垫片中重写<code>Object.getPrototypeOf()</code>，如果传入对象的<code>__proto__</code>属性存在，那么就返回<code>__proto__</code>属性，也就是父类构造函数。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/29/gulpIncrementalBuild/" class="prev">PREV</a><a href="/2015/12/24/es6InSublime/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'fedviccom';
var disqus_identifier = '2016/01/15/extendInBabel/';
var disqus_title = '从babel编译es6类继承的一个坑说起';
var disqus_url = 'http://fedvic.com/2016/01/15/extendInBabel/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fedviccom.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://fedvic.com">vic</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>