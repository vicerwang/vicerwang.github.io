<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Gulp中的增量编译 · Vic's Posts</title><meta name="description" content="Gulp中的增量编译 - vic"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/avatar.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/vicerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/wang-jin-liang-69" target="_blank" class="nav-list-link">ZHIHU</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gulp中的增量编译</h1><div class="post-meta"><div class="post-time">Jan 29, 2016</div></div><div class="post-content"><p><a href="http://gulpjs.com" target="_blank" rel="external">Gulp.js</a>是目前前端非常流行的自动化构建工具，它基于流，代码优于配置，API简单，又有着大量优秀的第三方插件。它的<code>gulp.watch()</code>接口，可以让我们监听文件改动而进行自动构建，但是如果存在耗时的任务或者随着项目的逐渐增大，可能每次构建都要花费很多的时间，那么在Gulp中有什么解决的办法呢？<br><a id="more"></a></p>
<p>其实在Gulp的文档中对于增量编译有推荐下面<a href="https://github.com/gulpjs/gulp#incremental-builds" target="_blank" rel="external">4个插件</a>：</p>
<ul>
<li><a href="https://github.com/sindresorhus/gulp-changed" target="_blank" rel="external">gulp-changed</a> - only pass through changed files</li>
<li><a href="https://github.com/contra/gulp-cached" target="_blank" rel="external">gulp-cached</a> - in-memory file cache, not for operation on sets of files</li>
<li><a href="https://github.com/ahaurw01/gulp-remember" target="_blank" rel="external">gulp-remember</a> - pairs nicely with gulp-cached</li>
<li><a href="https://github.com/tschaub/gulp-newer" target="_blank" rel="external">gulp-newer</a> - pass through newer source files only, supports many:1 source:dest</li>
</ul>
<p>那么他们的具体用法和区别是什么呢？</p>
<h2 id="gulp-cached"><a href="#gulp-cached" class="headerlink" title="gulp-cached"></a><a href="https://github.com/contra/gulp-cached" target="_blank" rel="external">gulp-cached</a></h2><p>gulp-cached可以将第一次传递给它的文件内容保留在内存中，如果之后再次执行task，它会将传递给它的文件和内存中的文件进行比对，如果内容相同，就不再将该文件继续向后传递，从而做到了只对修改过的文件进行增量编译。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"><span class="keyword">var</span> cached = <span class="built_in">require</span>(<span class="string">'gulp-cached'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(cached(<span class="string">'less'</span>))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'less'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>gulp-cached插件还可以接收一个可选的optimizeMemory参数，插件默认会将文件内容保存在内存中，如果将optimizeMemory设置为true，那么会转而将文件的md5值保留在内存中，从而减少对内存的占用，但是另一方面计算md5值也会消耗更多的时间，插件的作者建议在一般情况下，并不需要开启这个功能。</p>
<p>但是，gulp-cached在使用时也有一些限制，比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> cached = <span class="built_in">require</span>(<span class="string">'gulp-cached'</span>);</span><br><span class="line"><span class="keyword">var</span> remember = <span class="built_in">require</span>(<span class="string">'gulp-remember'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(cached(<span class="string">'concat'</span>))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(remember(<span class="string">'concat'</span>))</span><br><span class="line">        .pipe(concat(<span class="string">'all.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'concat'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个监听less文件改动并自动编译成css文件后合并的task，考虑一下这种情况，在修改文件a.less后，触发了concat的task，但是由于此时并没有修改文件b.less，所以传递给gulp-concat插件的b.less被gulp-cached过滤掉了，导致最后生成的all.css文件中只有修改后的a.less编译成的内容。那如何解决这个问题呢，此时就需要借助gulp-remember了。</p>
<h2 id="gulp-remember"><a href="#gulp-remember" class="headerlink" title="gulp-remember"></a><a href="https://github.com/ahaurw01/gulp-remember" target="_blank" rel="external">gulp-remember</a></h2><p>gulp-remember同样可以在内存中缓存所有曾经传递给它的文件，但是它和gulp-cached的区别是，在之后的task中，gulp-cached会过滤掉未经修改的文件不再向下传递，而gulp-remember则会将未传递给它的文件进行补足从而能够继续向下传递，因此通过gulp-cached和gulp-remember的结合使用，既能做到只对修改过的文件进行编译，又能做到当相关联的文件任意一个发生改变时，编译所有相关的文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> cached = <span class="built_in">require</span>(<span class="string">'gulp-cached'</span>);</span><br><span class="line"><span class="keyword">var</span> remember = <span class="built_in">require</span>(<span class="string">'gulp-remember'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(cached(<span class="string">'concat'</span>))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(remember(<span class="string">'concat'</span>))</span><br><span class="line">        .pipe(concat(<span class="string">'all.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'concat'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于在第一次合并文件时，gulp-remember已经将传递过来的文件缓存在内存中了，那么即使在后续的task执行中，gulp-cached插件过滤掉了未经修改过的less文件，但是gulp-remember还是能够通过自己的缓存来补全这些缺失的文件，从而做到正确地合并文件。你可能要问了对于这种情况，为什么还要额外引入两个插件，直接监听文件改动重新编译不就好了么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(concat(<span class="string">'all.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>相比上面这种不使用插件方式，gulp-cached和gulp-remember的结合使用还是有一定优势的：<br>gulp-remember缓存的是less文件编译后生成的css文件，这样只有修改了的less文件才需要重新编译成css文件，其他less文件对应的css文件可以直接从gulp-remember的缓存中读取，而不使用插件的方式每次都要重现编译所有的less文件。</p>
<p>另外，不要忘了我们还可以合理的管理两个插件的缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watcher = gulp.watch(<span class="string">'./src/*.less'</span>, [<span class="string">'concat'</span>]);</span><br><span class="line">    watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.type);</span><br><span class="line">        <span class="keyword">if</span> (event.type === <span class="string">'deleted'</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cached.caches[<span class="string">'concat'</span>][event.path];</span><br><span class="line">            remember.forget(<span class="string">'concat'</span>, <span class="built_in">require</span>(<span class="string">'gulp-util'</span>).replaceExtension(event.path, <span class="string">'.css'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="gulp-changed"><a href="#gulp-changed" class="headerlink" title="gulp-changed"></a><a href="https://github.com/sindresorhus/gulp-changed" target="_blank" rel="external">gulp-changed</a></h2><p>gulp-changed插件也能够像gulp-cached插件一样过滤未修改过的文件做到增量编译，不同之处主要在于如何判断文件被修改过，gulp-cached是通过对文件设置缓存来进行比较，而gulp-changed则是通过比较源文件和生成文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> changed = <span class="built_in">require</span>(<span class="string">'gulp-changed'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="keyword">var</span> pngquant = <span class="built_in">require</span>(<span class="string">'imagemin-pngquant'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'img'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/img/*'</span>)</span><br><span class="line">        .pipe(changed(<span class="string">'./dist/img'</span>))</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            progressive: <span class="literal">true</span>,</span><br><span class="line">            use: [pngquant()]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/img'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/img/*.png'</span>, [<span class="string">'img'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于gulp-changed是比较源文件和生成文件，所以调用插件的时候，要传入生成的位置，一般就是最后<code>gulp.dest()</code>方法要传入的参数。插件默认比较的是文件修改的时间，如果不同，就说明源文件有被修改过。另外可以通过hasChanged参数来使用插件内置的另一种<br>比较方式：<code>changed(&#39;dist&#39;, {hasChanged: changed.compareSha1Digest})</code>，也就是通过计算文件内容的sha1值来比较，一般情况下，生成文件的内容都是不同于源文件的，除非只是简单的拷贝，所以说基本上没什么用，hasChanged参数也支持传入一个函数来进行自定义比较。</p>
<p>在使用gulp-changed插件时有一个需要注意的地方，如果在task中改变了文件的后缀名，那么就需要通过extension参数来指定新的后缀名，否则插件无法找到生成的文件，比较令人遗憾的是，对于这种情况gulp-changed插件不会有任何提示，只是默默的执行了task，但是完全没有起到增量编译的目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> changed = <span class="built_in">require</span>(<span class="string">'gulp-changed'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(changed(<span class="string">'./dist'</span>, &#123;</span><br><span class="line">            extension: <span class="string">'.css'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'less'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="gulp-newer"><a href="#gulp-newer" class="headerlink" title="gulp-newer"></a><a href="https://github.com/tschaub/gulp-newer" target="_blank" rel="external">gulp-newer</a></h2><p>gulp-newer既可以像gulp-cached/gulp-changed那样1对1地进行增量编译，也可以像gulp-cached配合gulp-remember那样多对1地进行增量编译。它实现增量编译的原理和gulp-changed相同，都是通过比较源文件和生成文件，只不过它只支持比较修改时间。</p>
<p>先来看一个1对1进行增量编译的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> newer = <span class="built_in">require</span>(<span class="string">'gulp-newer'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(newer(&#123;</span><br><span class="line">            dest: <span class="string">'./dist'</span>,</span><br><span class="line">            ext: <span class="string">'.css'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'less'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>多对1增量编译的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> newer = <span class="built_in">require</span>(<span class="string">'gulp-newer'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(newer(<span class="string">'./dist/all.css'</span>))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(concat(<span class="string">'all.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'src/*.less'</span>, [<span class="string">'less'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我目前的看法是借助gulp-newer进行多对1的增量编译和直接监听文件自动编译的区别并不是很大（它和gulp-cached配合gulp-remember使用还是有区别的，没有办法带来之前说的缓存编译结果的好处），可能唯一的好处就是下面说的这种情况：通过<code>gulp.watch()</code>监听了所有的文件，但是触发task的源文件只有a文件和b文件，那么此时修改不相关的c文件，gulp-newer可以防止重复编译a文件和b文件情况的出现。关于gulp-newer和gulp-changed，你也可以参考下<a href="http://stackoverflow.com/questions/24730215/gulp-newer-vs-gulp-changed" target="_blank" rel="external">Stackoverflow</a>上对他们的比较。</p>
<h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp-watch"></a><a href="https://github.com/floatdrop/gulp-watch" target="_blank" rel="external">gulp-watch</a></h2><p>除了上面介绍的和<code>gulp.watch()</code>配合使用的4个插件外，我们还可以直接借助gulp-watch插件来完成增量编译。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> watch = <span class="built_in">require</span>(<span class="string">'watch'</span>);</span><br><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch-less'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.less'</span>)</span><br><span class="line">        .pipe(watch(<span class="string">'./src/*.less'</span>))</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>gulp-watch可以做到和gulp原生API<code>gulp.watch()</code>一样监听文件改动，并且由于它是整个task的一环，因此每次文件改动时，只有这个被改动的文件会被gulp-watch继续向下传递，而且这种写法也更接近于我们使用gulp插件的方式。另外还有的一个好处是执行<code>watch-less</code>task，会自动运行一次编译less的task，而<code>gulp.watch()</code>在启动时，则什么都不会做。不过gulp-watch也有它的限制，无法处理concat这样的task，具体原因可以参考<a href="https://github.com/floatdrop/gulp-watch/issues/6" target="_blank" rel="external">这里</a>。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/15/extendInBabel/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'fedviccom';
var disqus_identifier = '2016/01/29/gulpIncrementalBuild/';
var disqus_title = 'Gulp中的增量编译';
var disqus_url = 'http://fedvic.com/2016/01/29/gulpIncrementalBuild/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fedviccom.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://fedvic.com">vic</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>